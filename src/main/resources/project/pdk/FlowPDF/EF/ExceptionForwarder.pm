# WARNING
# Do not edit this file manually. Your changes will be overwritten with next FlowPDF update.
# WARNING

# The purpose of this package is to forward caught exception to the pipeline/procedure/schedule summary.

package FlowPDF::EF::ExceptionForwarder;
use base qw/FlowPDF::BaseClass2/;
use FlowPDF::Types;
__PACKAGE__->defineClass({
    ec           => FlowPDF::Types::Reference('ElectricCommander'),
    pluginObject => FlowPDF::Types::Any()
});

use strict;
use warnings;

use Carp;

use Data::Dumper;
use Try::Tiny;
use ElectricCommander;

use FlowPDF::Log;
use FlowPDF::Log::FW;

# TODO: Add documentation for this package.

sub new {
    my ($class, @params) = @_;

    my $self = $class->SUPER::new(@params);

    if (!$self->getEc()) {
        $self->setEc(ElectricCommander->new());
    }

    return $self;
}


sub forward {
    my ($self, $e, $opts) = @_;

    my $po = $self->getPluginObject();
    my $minimalContext = $po->newContext({minimal => 1});
    my $stepResult = $minimalContext->newStepResult();
    $stepResult->flush();
    my $fullExceptionString;
    my $briefExceptionString;
    # this handler for FlowPDF::Exception::*
    my $isFlowPDFException = 0;
    if (ref($e) && ref($e) =~ m/^FlowPDF::Exception/s) {
        $fullExceptionString = $e->toString();
        $briefExceptionString = $e->toString({dropStackTrace => 1});
        $isFlowPDFException = 1;
    }
    # This for regular die/croak
    else {
        $fullExceptionString = $e;
        $briefExceptionString = $e;
    }
    logErrorDiag($fullExceptionString);
    if ($minimalContext->getRunContext() eq 'pipeline') {
        $stepResult->setPipelineSummary('Unhandled Exception:', $briefExceptionString);
    }
    $stepResult->setJobStepOutcome('error');
    $stepResult->setJobStepSummary($briefExceptionString);

    # apply if not applied
    $stepResult->applyIfNotApplied();

    if ($opts && $opts->{throw}) {
        if ($isFlowPDFException) {
            $e->throw();
        }
        else {
            croak $e;
        }
    }
}
